"""
문제
지훈이가 최근에 즐기는 컴퓨터 게임이 있다. 이 게임은 여러 플레이어가 참여하며, 
각 플레이어는 특정한 색과 크기를 가진 자기 공 하나를 조종하여 게임에 참여한다. 
각 플레이어의 목표는 자기 공보다 크기가 작고 색이 다른 공을 사로잡아 그 공의 크기만큼의 점수를 얻는 것이다. 
그리고 다른 공을 사로잡은 이후에도 본인의 공의 색과 크기는 변하지 않는다. 
다음 예제는 네 개의 공이 있다. 편의상 색은 숫자로 표현한다.

공 번호	색	크기
1	1	10
2	3	15
3	1	3
4	4	8
이 경우, 2번 공은 다른 모든 공을 사로잡을 수 있다. 반면, 1번 공은 크기가 더 큰 2번 공과 색이 같은 3번 공은 잡을 수 없으며, 단지 4번 공만 잡을 수 있다. 

공들의 색과 크기가 주어졌을 때, 각 플레이어가 사로잡을 수 있는 모든 공들의 크기의 합을 출력하는 프로그램을 작성하시오. 

입력
첫 줄에는 공의 개수를 나타내는 자연수 N이 주어진다(1 ≤ N ≤ 200,000). 
다음 N개의 줄 중 i번째 줄에는 i번째 공의 색을 나타내는 자연수 Ci와 그 크기를 나타내는 자연수 Si가 주어진다(1 ≤ Ci ≤ N, 1 ≤ Si ≤ 2,000). 
서로 같은 크기 혹은 같은 색의 공들이 있을 수 있다.

출력
N개의 줄을 출력한다. N개의 줄 중 i번째 줄에는 i번째 공을 가진 플레이어가 잡을 수 있는 모든 공들의 크기 합을 출력한다.

=========================================================================================================================================================

n <= 20만 이기때문에 O(N^2) 는 time over 발생한다.
따라서 누적합을 통해 시간 단축이 필요하다.

현재 player가 획득 가능한 점수 = 현재까지 모든 누적합 - 현재까지의 색깔 별 누적합 으로 계산한다.
"""
n = int(input())
ball = []
for i in range(n):
    c, s = map(int, input().split())
    ball.append([i, c, s])
## 정렬 => 크기 순서대로 정렬하고 같은 크기에서는 색깔 순서로 정렬한다.
ball = sorted(ball, key=lambda x: [x[2],x[1]])

color_sum = [0] * (n+1)
ans = [0]*(n+1)
total = 0
idx = 0 ## 비교할 index
for i in range(n): ## i 가 기준점이 된다.
    ## 중요한 것은 2중 for문을 사용시 결국 brute force가 되기  때문에 while문으로 단축시켜준다.
    while ball[idx][2] < ball[i][2]: ## 크기가 작을 경우만 진행한다.
        total += ball[idx][2] ## total은 모두 더해준다.
        color_sum[ball[idx][1]] += ball[idx][2] ## 색깔 별로 현재까지의 합을 구한다.
        idx +=1 ## 비교대상 shift

    ## 현재 획득 가능한 점수 : 현재까지의 점수 - 현재 색깔의 합
    ans[ball[i][0]] = total - color_sum[ball[i][1]]

## 출력
for i in range(n):
    print(ans[i])