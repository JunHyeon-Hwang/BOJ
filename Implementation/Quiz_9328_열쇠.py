"""
문제
상근이는 1층 빌딩에 침입해 매우 중요한 문서를 훔쳐오려고 한다. 상근이가 가지고 있는 평면도에는 문서의 위치가 모두 나타나 있다. 
빌딩의 문은 모두 잠겨있기 때문에, 문을 열려면 열쇠가 필요하다. 
상근이는 일부 열쇠를 이미 가지고 있고, 일부 열쇠는 빌딩의 바닥에 놓여져 있다. 상근이는 상하좌우로만 이동할 수 있다.

상근이가 훔칠 수 있는 문서의 최대 개수를 구하는 프로그램을 작성하시오.

입력
첫째 줄에 테스트 케이스의 개수가 주어진다. 테스트 케이스의 수는 100개를 넘지 않는다.

각 테스트 케이스의 첫째 줄에는 지도의 높이와 너비 h와 w (2 ≤ h, w ≤ 100)가 주어진다. 다음 h개 줄에는 빌딩을 나타내는 w개의 문자가 주어지며, 각 문자는 다음 중 하나이다.

'.'는 빈 공간을 나타낸다.
'*'는 벽을 나타내며, 상근이는 벽을 통과할 수 없다.
'$'는 상근이가 훔쳐야하는 문서이다.
알파벳 대문자는 문을 나타낸다.
알파벳 소문자는 열쇠를 나타내며, 그 문자의 대문자인 모든 문을 열 수 있다.
마지막 줄에는 상근이가 이미 가지고 있는 열쇠가 공백없이 주어진다. 만약, 열쇠를 하나도 가지고 있지 않는 경우에는 "0"이 주어진다.

상근이는 처음에는 빌딩의 밖에 있으며, 빌딩 가장자리의 벽이 아닌 곳을 통해 빌딩 안팎을 드나들 수 있다. 
각각의 문에 대해서, 그 문을 열 수 있는 열쇠의 개수는 0개, 1개, 또는 그 이상이고, 각각의 열쇠에 대해서, 그 열쇠로 열 수 있는 문의 개수도 0개, 1개, 또는 그 이상이다. 
열쇠는 여러 번 사용할 수 있다.

출력
각 테스트 케이스 마다, 상근이가 훔칠 수 있는 문서의 최대 개수를 출력한다.

===========================================================================================================================================================================================

문을 열면 . 로 변경하고 다시 처음부터 탐색하는 방식으로 해결한다. => visited도 초기화 필요하다.
"""


from collections import deque
dx = [0,1,0,-1]
dy = [1,0,-1,0]
t = int(input())
for _ in range(t):
    h, w = map(int,input().split())
    _map = [['.']*(w+2) for _ in range(h+2)] ## 맵 태두리를 '.' 를 추가하여 맵 외부에서 돌아다닐수 있도록 한다. => 모든 출발 위치를 고려할 수 있다.
    
    for i in range(1,h+1): ## map 입력
        _map[i][1:-1] = list(map(str,input()))
    keys = list(map(str, input()))
    
    ## doors dictionary를 통해 열쇠를 찾으면 문 위치 기억해두고 바로 접근해 열도록 한다.
    doors = {chr(alpha) : [] for alpha in range(ord('A'), ord('Z')+1)}
    
    ## keys 가 없다면 굳이 map을 돌면서 문 열 필요 없다.
    if keys != '0': 
        for i in range(1,h+1):
            for j in range(1,w+1):
                if 'A'<= _map[i][j] <='Z': ## 문일때
                    if _map[i][j].lower() in keys: ## 열쇠가 있다면
                        _map[i][j] = '.' ## 문을 제거해버린다.
                    else: ## 열쇠 없다면 문 위치 기억해둔다.
                        doors[_map[i][j]].append((i,j))
                
                elif 'a' <= _map[i][j] <= 'z': ## 미리 갖고 있는 열쇠도 제거해버린다.
                    if _map[i][j] in keys:
                        _map[i][j] = '.'
                        
    del keys ## 미리 갖고 있는 열쇠 사용 끝났으니 메모리 제거한다.
    
    ## 찾은 문서 개수
    cnt = 0
    
    ## bfs 탐새
    def bfs(x, y, cnt):
        queue = deque()
        visited = [[0]*(w+2) for _ in range(h+2)]
        queue.append((x,y))
        visited[x][y] = 1
        
        while queue:
            cur_x, cur_y = queue.popleft()
            for i in range(4):
                nx, ny = cur_x+dx[i], cur_y+dy[i]
                if 0<=nx<=(h+1) and 0<=ny<=(w+1):
                    ## 아직 방문하지 않았고 이동 가능하다면 queue에 저장한다.
                    if not visited[nx][ny] and _map[nx][ny] == '.': 
                        queue.append((nx,ny))
                        visited[nx][ny] =1
                    
                    ## 방문하지 않았고, 열쇠를 발견했을 때 
                    elif not visited[nx][ny] and 'a' <= _map[nx][ny] <= 'z':
                        ## 열쇠에 해당하는 문이 있다면 그 문은 제거하고 다시 처음부터 탐색한다.
                        if doors[_map[nx][ny].upper()]:
                            ## 문 모두 제거한다.
                            for d_x, d_y in doors[_map[nx][ny].upper()]:
                                _map[d_x][d_y] = '.'
                            ## 처음부터 탐색하기 위해 queue와 visited 초기화 필요하다.
                            while True:
                                queue = deque()
                                visited = [[0]*(w+2) for _ in range(h+2)]
                                ## 시작부분만 다시 체크한다.
                                queue.append((x,y))
                                visited[x][y] =1
                                break
                        ## 열쇠에 해당하는 문이 없다면 열쇠만 줍고 다음 탐색 유지한다.
                        else:
                            queue.append((nx,ny))
                            visited[nx][ny] = 1
                        ## 열쇠 부분 '.' 로 변경한다.
                        _map[nx][ny] = '.'
                        
                    ## 방문하지 않았고 문서 발견했다면 중복으로 발견하지 않도록 '.' 로 제거하고 다음 탐색 진행한다.
                    elif not visited[nx][ny] and _map[nx][ny] =='$':
                        queue.append((nx,ny))
                        visited[nx][ny] =1
                        _map[nx][ny] = '.'
                        cnt += 1
        
        return cnt
    
    cnt = bfs(0,0, cnt)
    print(cnt)
                        
                        

# 15 15
# **$*.**********
# ****.*******$**
# ****..$****..**
# $*****c*****.**
# *.$.*****fD..**
# *$*xd******.**$
# $..********..**
# **h********....
# ***************
# ***.i**********
# ***.***.K$*****
# *k.$$I.$*******
# ******.$..j***$
# *******D*******
# ****$**F*******
# za