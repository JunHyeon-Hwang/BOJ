"""
문제
NASA에서는 화성 탐사를 위해 화성에 무선 조종 로봇을 보냈다. 
실제 화성의 모습은 굉장히 복잡하지만, 로봇의 메모리가 얼마 안 되기 때문에 지형을 N×M 배열로 단순화 하여 생각하기로 한다.

지형의 고저차의 특성상, 로봇은 움직일 때 배열에서 왼쪽, 오른쪽, 아래쪽으로 이동할 수 있지만, 위쪽으로는 이동할 수 없다. 
또한 한 번 탐사한 지역(배열에서 하나의 칸)은 탐사하지 않기로 한다.

각각의 지역은 탐사 가치가 있는데, 로봇을 배열의 왼쪽 위 (1, 1)에서 출발시켜 오른쪽 아래 (N, M)으로 보내려고 한다. 
이때, 위의 조건을 만족하면서, 탐사한 지역들의 가치의 합이 최대가 되도록 하는 프로그램을 작성하시오.

입력
첫째 줄에 N, M(1≤N, M≤1,000)이 주어진다. 다음 N개의 줄에는 M개의 수로 배열이 주어진다. 
배열의 각 수는 절댓값이 100을 넘지 않는 정수이다. 이 값은 그 지역의 가치를 나타낸다.

출력
첫째 줄에 최대 가치의 합을 출력한다.
================================================================================================================================
DP 를 만들어 해결한다.
맨 윗줄은 => 진행만 가능하니 초기 값으로 설정한다.

두 번째 줄부터는 아래로 진행과 오른쪽과 왼쪽 방향이 가능하다.
먼저 아래로 진행한 뒤 오른쪽, 왼쪽을 진행한다.
다만, 이 중 어느 방향으로든 바로 갱신시켜버리면 중복 방문되는 일이 발생할 수 있다.
따라서 temp에 오른쪽, 왼쪽 방향별로 담아두고 그 중 큰 값을 dp에 입력한다.
"""

n,m = map(int, input().split())
mars = [list(map(int, input().split())) for _ in range(n)]
dp = [[float('-Inf')]*m for _ in range(n)]
temp = [[[float('-inf'), float('-inf')] for _ in range(m) ] for _ in range(n)]


dp[0][0] = mars[0][0]
for i in range(1, m):
    dp[0][i] = dp[0][i-1] + mars[0][i]
for i in range(1, n):
    for j in range(m):
        temp[i][j][0] = dp[i-1][j] + mars[i][j]
        temp[i][j][1] = dp[i-1][j] + mars[i][j]
    for j in range(1, m):
        temp[i][j][0] = max(temp[i][j-1][0] + mars[i][j], temp[i][j][0])
        
    for j in range(m-2, -1,-1):
        temp[i][j][1] = max(temp[i][j+1][1] + mars[i][j], temp[i][j][1])
        
    for j in range(m):
        dp[i][j] = max(temp[i][j][0], temp[i][j][1])
        
        
    
print(dp[n-1][m-1])
