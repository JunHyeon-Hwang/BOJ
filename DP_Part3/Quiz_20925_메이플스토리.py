"""
문제
상원이는 겨울방학 동안 메이플스토리를 할 것이다. 개강 후에는 바쁘기 때문에 방학 동안 최대한 레벨을 많이 올리려고 한다.



메이플스토리에는 여러 가지 사냥터가 있다. 각 사냥터는 입장에 필요한 최소 레벨, 지형, 몬스터 레벨, 몬스터 수, 버닝 등등 다양한 특징을 가진다. 
상원이는 경험치가 가장 중요하기 때문에 사냥터의 특징을 입장에 필요한 최소 경험치와  $1$분마다 얻는 경험치로 간략화했다. 
사냥을 시작하고 매 분마다 지금 있는 사냥터에서 계속 사냥할지 다른 사냥터로 갈지 결정한다. 
코디 아이템에 돈을 다 써 텔레포트를 할 수 없는 상원이는 사냥터 사이를 직접 걸어서 이동한다. 
사냥터 사이를 이동하는 동안 사냥을 할 수 없기 때문에 경험치를 얻을 수 없다.

처음에 캐릭터의 경험치는 $0$이기 때문에 입장에 필요한 최소 경험치가 $0$인 사냥터 중 하나를 골라 사냥을 시작한다. 
상원이가 방학 동안 얻을 수 있는 경험치의 최댓값을 알려주자.

입력
첫째 줄 사냥터 수 $N$ ($1 \le N \le 200$)과 방학 기간을 분 단위로 나타낸 $T$ ($1 \le T \le 1\,000$)가 주어진다.

다음 $N$개의 줄에는 $i$번째 사냥터의 특징인 입장에 필요한 최소 경험치 $c_i$와  $1$분마다 얻는 경험치 $e_i$가 주어진다. ($0 \le c_i, e_i \le 1\,000\,000$)

다음 $N$개의 줄에는 각 사냥터 사이를 이동하는 데 걸리는 시간이 주어진다. 
$i$번째 줄의 $j$번째 수는 $i$번 사냥터에서 $j$번 사냥터로 이동하여 입장하는 데까지 걸리는 시간을 분 단위로 나타낸 값 $t_{i,j}$이다. 
($1 \le t_{i,j} \le 1\,000$, $t_{i,j}=t_{j,i}$, $t_{i,i}=0$)

단, 입장에 필요한 최소 경험치  $c_i$가 $0$인 사냥터는 반드시 하나 이상 존재한다.

출력
상원이가 방학 동안 얻을 수 있는 경험치의 최댓값을 출력한다.
======================================================================================================================================================
💥 Pypy3 => AC
    Python => TLE
"""

N, T = map(int, input().split())
min_exp = [] ## 사냥터 입장 가능한 최소 경험치 
exp = [] ## 분당 경험치
dp = [[-1]*N for _ in range(T+1)] ## 사냥터에 따른 누적 경험치 // -> T x N  // dp[t][n] => t시간에 n번째 사냥터에서의 최대 경험치를 의미한다.
for i in range(N):
    c, e = map(int, input().split())
    min_exp.append(c)
    exp.append(e)
    if c == 0: ## 시작 가능한 사냥터 위치 갱신
        dp[0][i] = 0
        
## 이동 시간
cost = [list(map(int, input().split())) for _ in range(N)]

for time in range(1, T+1): ## time 1씩 증가하며 사냥터 경험치 갱신한다.
    for ground in range(N): ## 현재 사냥터
        for prev_ground in range(N): ## 이전 사냥터
            
            ## 이전 사냥터에서 현재 사냥터로 이동하는데 걸린 시간만큼 현재 시간에서 빼준다. => 이동 전 경험치를 알 수 있다.
            prev_time = time - cost[prev_ground][ground] 
            
            ## 사냥터 이동이 이루어지지 않았다.
            if ground == prev_ground:
                ## 경험치 획득이 있다면 이전 경험치에 현재 사냥터에서의 경험치를 더한 값과 기존 값을 비교해 더 큰 값을 기록한다.
                if dp[time-1][ground] != -1: 
                    dp[time][ground] = max(dp[time][ground], dp[time-1][ground] + exp[ground])
                else: ## 현재 사냥터에서 이전 시간대에 경험치 획득이 없다면 아직 이 사냥터는 이용 불가를 의미한다.
                    continue
            ## 현재 사냥터로 이동하기 전 사냥터에서의 시간대가 음수라면 불가능한 경우이다
            elif prev_time < 0: continue
            ## 이전 사냥터에서의 경험치가 현재 사냥터의 최소 경험치보다 크다면 이제 이용가능해짐을 의미한다.
            elif dp[prev_time][prev_ground] >= min_exp[ground]:
                dp[time][ground] = max(dp[time][ground], dp[prev_time][prev_ground])
                
## 출력.
print(max(dp[-1]))